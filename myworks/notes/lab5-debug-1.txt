
1. badsegment

break copy_thread

initproc
(gdb) p/x proc->tf
$1 = 0xc038bfb4
(gdb) p/x proc    
$2 = 0xc0389090

3rd
(gdb) p/x proc->tf
$3 = 0xc0392fb4
(gdb) p/x proc
$4 = 0xc0389118




++ setup timer interrupts
kernel_execve: pid = 2, name = "badsegment".
user_main: name = "badsegment", binary = "0xc01323d5", size = "30897"
trapframe at 0xc0392fb4     tf是3rd的tf
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x00000000
  ecx  0x00000000
  eax  0x00000028
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000d General Protection
  err  0x00000028
  eip  0x00800f9e
  cs   0x----001b
  flag 0x00000286 PF,SF,IF,IOPL=0
  esp  0xafffff90
  ss   0x----0023
unhandled trap.
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:472:
    initproc exit.

stack trackback:
ebp:0xc038bf88 eip:0xc0100aeb args:0xc010c564 0xc038bfcc 0x000001d8 0xc038bfb8
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc038bfb8 eip:0xc0100e4b args:0xc010e32d 0x000001d8 0xc010e37f 0x00000000
    kern/debug/panic.c:28: __panic+105
ebp:0xc038bfe8 eip:0xc010a352 args:0x00000000 0x00000000 0x00000000 0x00000010
    kern/process/proc.c:472: do_exit+91
Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.


每个被创建的进程 线程中都有一个 tf，位于 其栈的最顶端

注意看，initproc和3rd 的 tf的位置都是在内核空间，3G以上

struct Page *page = alloc_pages(KSTACKPAGE);
proc->kstack = (uintptr_t)page2kva(page);
proc->tf = (struct trapframe *)(proc->kstack + KSTACKSIZE) - 1;

虽然最后用户进程会在0xB000000处有一个用户栈
但是在其内核空间，还是有一个和他对应的内核栈的，通过上面的方式进行分配

load_icode：这是用户空间的栈，execv完毕后，iret时，会将这些值恢复到寄存器中
    tf->tf_cs = USER_CS;
    tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
    tf->tf_esp = USTACKTOP;
    tf->tf_eip = (uintptr_t)(0x800020);
    tf->tf_eflags |= FL_IF;



----------
    

(gdb) 
Run till exit from #0  trap_dispatch (tf=0xc0392f50) at kern/trap/trap.c:227
trap (tf=0xc0392f50) at kern/trap/trap.c:321
(gdb) p/x otf
$13 = 0xc0392fb4
(gdb) p/x current->tf
$14 = 0xc0392f50

void
trap(struct trapframe *tf) {
    // dispatch based on what type of trap occurred
    // used for previous projects
    if (current == NULL) {
        trap_dispatch(tf);
    }
    else {
        // keep a trapframe chain in stack
        struct trapframe *otf = current->tf;    // otf: 0xc0392fb4
        current->tf = tf;           // tf: 0xc0392f50   执行到这一步时，会将current->tf 替换成一个新的 tf，去执行中断服务例程
    
        bool in_kernel = trap_in_kernel(tf);
    
        trap_dispatch(tf);
    
        current->tf = otf;          // 执行完毕中断服务例程后，替换成旧的tf  为什么要这样 【Q】？？？？？
        if (!in_kernel) {
            if (current->flags & PF_EXITING) {
                do_exit(-E_KILLED);
            }
            if (current->need_resched) {
                schedule();
            }
        }
    }
}


执行完毕中断服务例程时：
    
(gdb) b do_execve
Breakpoint 2 at 0xc010ab33: file kern/process/proc.c, line 674.
(gdb) c
Continuing.

Breakpoint 2, do_execve (name=0xc010e588 "badsegment", len=10, binary=0xc01323d5 "\177ELF\001\001\001", size=30897) at kern/process/proc.c:674
(gdb) n
(gdb) p/x current   3rd在do_execve中替换自己的程序映像为用户程序
$1 = 0xc0389118
(gdb) b load_icode
Breakpoint 3 at 0xc010a4cc: file kern/process/proc.c, line 525.
(gdb) c
Continuing.

Breakpoint 3, load_icode (binary=0xc01323d5 "\177ELF\001\001\001", size=30897) at kern/process/proc.c:525
(gdb) n
(gdb) p/x current->mm
$2 = 0x0
(gdb) p/x current->tf       
$3 = 0xc0392f50
(gdb) 


load_icode中执行重新赋值之前

(gdb) p/x *tf
$6 = {tf_regs = {reg_edi = 0x78b1, reg_esi = 0x78b1, reg_ebp = 0xc0392fcc, reg_oesp = 0xc0392f70, reg_ebx = 0xc01323d5, reg_edx = 0xc010e588, reg_ecx = 0xa, reg_eax = 0x4}, tf_gs = 0x0, tf_padding0 = 0x0, tf_fs
= 0x0, tf_padding1 = 0x0, tf_es = 0x10, tf_padding2 = 0x0, tf_ds = 0x10, tf_padding3 = 0x0, tf_trapno = 0x80, tf_err = 0x0, tf_eip = 0xc010aebc, tf_cs = 0x8, tf_padding4 = 0x0, tf_eflags = 0x286, tf_esp = 0xc010
e554, tf_ss = 0xe588, tf_padding5 = 0xc010}
(gdb) n
赋值后
(gdb) 
(gdb) p/x *tf
$7 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_gs = 0x0, tf_padding0 = 0x0, tf_fs = 0x0, tf_padding1 = 0x0, tf_es =
0x23, tf_padding2 = 0x0, tf_ds = 0x23, tf_padding3 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0x800020, tf_cs = 0x1b, tf_padding4 = 0x0, tf_eflags = 0x200, tf_esp = 0xb0000000, tf_ss = 0x23, tf_padding5 = 0x
0}
(gdb) 


tf_cs = 0x8                 tf_cs = 0x1b
tf_ds = 0x10                tf_ds = 0x23
tf_es = 0x10                tf_es = 0x23
tf_ss = 0xe588              tf_ss = 0x23
tf_esp = 0xc010e554         tf_esp = 0xb0000000
tf_eip = 0xc010aebc         tf_eip = 0x800020
tf_eflags = 0x286           tf_eflags = 0x200






【Q】执行完毕中断服务例程前后，为何要替换current的tf？
【A】tf 是从trap函数传进来的，表示执行完毕中断服务例程的入参，含有的是 __alltraps 中对 当前寄存器值在栈中的存储
该函数一开始将寄存器的值压栈，构造了一个 trap frame
个人觉得这些动作一方面是为了构造trap frame，以备中断服务例程使用当前的各个寄存器值，尤其是 tf->tf_trapno tf->tf_cs等
另一方面是为了保存这些寄存器值，在中断服务例程执行完毕后，将这些值恢复到寄存器中，恢复现场之用。

所以在调用中断服务例程前，将current的tf 替换成 构造的trap frame；
在中断服务例程调用完毕后，current就可以恢复之前的tf了，继续运行下去。

目前发现只有这一个地方会对current的tf进行替换和恢复。

(gdb) p/x *tf
$5 = {tf_regs = {reg_edi = 0x78b1, reg_esi = 0x78b1, reg_ebp = 0xc0392fcc, reg_oesp = 0xc0392f70, reg_ebx = 0xc01323d5, reg_edx = 0xc010e588, reg_ecx = 0xa, reg_eax = 0x4}, tf_gs = 0x0, tf_padding0 = 0x0, tf_fs
= 0x0, tf_padding1 = 0x0, tf_es = 0x10, tf_padding2 = 0x0, tf_ds = 0x10, tf_padding3 = 0x0, tf_trapno = 0x80, tf_err = 0x0, tf_eip = 0xc010aebc, tf_cs = 0x8, tf_padding4 = 0x0, tf_eflags = 0x286, tf_esp = 0xc010
e554, tf_ss = 0xe588, tf_padding5 = 0xc010}
(gdb) p/x *otf
$6 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xc0392fd8, reg_oesp = 0xc010aeca, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0xc0392fec, reg_eax = 0xc010af0d}, tf_gs = 0xe588, tf_padding0 = 0xc010, tf_fs
= 0x23d5, tf_padding1 = 0xc013, tf_es = 0x78b1, tf_padding2 = 0x0, tf_ds = 0x10, tf_padding3 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0x0, tf_cs = 0x96af, tf_padding4 = 0xc010, tf_eflags = 0x0, tf_esp = 0x
0, tf_ss = 0x10, tf_padding5 = 0x0}




【Q】

这些err是怎么来的？含义是什么
run_test -prog 'badsegment' -check default_check                \
        'kernel_execve: pid = 2, name = "badsegment".'          \
      - 'trapframe at 0xc.......'                               \
        'trap 0x0000000d General Protection'                    \
        '  err  0x00000028'                                     \
      - '  eip  0x008.....'           

trap 0x0000000d General Protection
err  0x00000028

【A】
https://wiki.osdev.org/Exceptions
https://wiki.osdev.org/Exceptions#General_Protection_Fault
https://wiki.osdev.org/Exceptions#Selector_Error_Code【！！！】

https://wiki.osdev.org/Exceptions#Page_Fault
https://wiki.osdev.org/Page_Fault
https://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol3/o_fe12b1e2a880e0ce-226.html


An error code on the stack. The error code for a page fault has a format different from that for other exceptions 
(see Figure 6-9). The processor establishes the bits in the error code as follows:
— P  flag  (bit 0).

This flag is 0 if there is no translation for the linear address because the P flag was 0 in one of the paging-
structure entries used to translate that address.

— W/R (bit 1).

If the access causing the page-fault exception was a write, this flag is 1; otherwise, it is 0. This flag 
describes the access causing the page-fault exception, not the access rights specified by paging.

— U/S (bit 2).

If a user-mode access caused the page-fault exception, this flag is 1; it is 0 if a supervisor-mode access did 
so. This flag describes the access causing the page-fault exception, not the access rights specified by 
paging.

— RSVD  flag  (bit 3).

This flag is 1 if there is no translation for the linear address because a reserved bit was set in one of the 
paging-structure entries used to translate that address.




https://en.wikipedia.org/wiki/Page_fault

----------------- 解释

https://wiki.osdev.org/Exceptions#General_Protection_Fault
https://wiki.osdev.org/Exceptions#Selector_Error_Code

General Protection Fault
A General Protection Fault may occur for various reasons. The most common are:
Segment error (privilege, type, limit, read/write rights).
Executing a privileged instruction while CPL != 0.
Writing a 1 in a reserved register field.
Referencing or accessing a null-descriptor.
Trying to access an unimplemented register (like: mov cr6, eax)
The saved instruction pointer points to the instruction which caused the exception.
Error code: The General Protection Fault sets an error code, which is the segment selector index when the exception is segment related. Otherwise, 0.

Selector Error Code

 31         16   15         3   2   1   0
+---+--  --+---+---+--  --+---+---+---+---+
|   Reserved   |    Index     |  Tbl  | E |
+---+--  --+---+---+--  --+---+---+---+---+
Length  Name    Description
E   1 bit   External    When set, the exception originated externally to the processor.
Tbl 2 bits  IDT/GDT/LDT table   This is one of the following values:
Value   Description
0b00    The Selector Index references a descriptor in the GDT.
0b01    The Selector Index references a descriptor in the IDT.
0b10    The Selector Index references a descriptor in the LDT.
0b11    The Selector Index references a descriptor in the IDT.
Index   13 bits Selector Index  The index in the GDT, IDT or LDT.



        'trap 0x0000000d General Protection'                    \
        '  err  0x00000028'  

当发生General Protection时，如果和段有关系，那么会在错误码中设置段索引号
否则，错误码是0
错误码不是0，是 0x00000028    101000
E       0       
Tbl     00    Index表示的是GDT索引
Index   101     5   GDT索引

memlayout.h 中定义了 
/* global segment number */
#define SEG_KTEXT   1
#define SEG_KDATA   2
#define SEG_UTEXT   3
#define SEG_UDATA   4
#define SEG_TSS     5

gdt_init中 调用了

// initialize the TSS filed of the gdt
gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);

badsegment.c测试用例中，想进行 asm volatile("movw $0x28,%ax; movw %ax,%ds");
但是当前是在用户空间的，所以 这个指令是不能执行的，会触发异常

        【Q】目前不知道这个和SEG_TSS有什么关系



【Q】eip  0x00800f9e 可以看出什么吗？
++ setup timer interrupts
kernel_execve: pid = 2, name = "badsegment".
user_main: name = "badsegment", binary = "0xc01323d5", size = "30897"
trapframe at 0xc0392fb4     tf是3rd的tf
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x00000000
  ecx  0x00000000
  eax  0x00000028
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000d General Protection
  err  0x00000028
  eip  0x00800f9e
  cs   0x----001b
  flag 0x00000286 PF,SF,IF,IOPL=0
  esp  0xafffff90
  ss   0x----0023

zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ objdump -d obj/__user_badsegment.out |grep 800f9e -C 20


00800f91 <main>:
  800f91:       55                      push   %ebp
  800f92:       89 e5                   mov    %esp,%ebp
  800f94:       83 e4 f0                and    $0xfffffff0,%esp
  800f97:       83 ec 10                sub    $0x10,%esp
  800f9a:       66 b8 28 00             mov    $0x28,%ax
  800f9e:       8e d8                   mov    %eax,%ds                 0x00800f9e
  800fa0:       c7 44 24 08 a0 12 80    movl   $0x8012a0,0x8(%esp)
  800fa7:       00
  800fa8:       c7 44 24 04 09 00 00    movl   $0x9,0x4(%esp)
  800faf:       00
  800fb0:       c7 04 24 ab 12 80 00    movl   $0x8012ab,(%esp)
  800fb7:       e8 73 f0 ff ff          call   80002f <__panic>


可以看到这一句就是 mov    %eax,%ds   可以看到当前是在用户空间的，所以 这个指令是不能执行的，会触发异常
从而知道c代码中的问题代码所在
这就是通过crash信息定位错误代码【！！！】

所以有时候在gdb层面想看一些寄存器的值，好像也算无法读取，是不是这个原因？



--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------

divzero

++ setup timer interrupts
kernel_execve: pid = 2, name = "divzero".
user_main: name = "divzero", binary = "0xc0139c86", size = "30975"
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x00000000
  ecx  0x00000000
  eax  0x00000001
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x00000000 Divide error
  err  0x00000000
  eip  0x00800fa6
  cs   0x----001b
  flag 0x00000286 PF,SF,IF,IOPL=0
  esp  0xafffff90
  ss   0x----0023
unhandled trap.
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:472:
    initproc exit.

stack trackback:
ebp:0xc038bf88 eip:0xc0100aeb args:0xc010c564 0xc038bfcc 0x000001d8 0xc038bfb8
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc038bfb8 eip:0xc0100e4b args:0xc010e32d 0x000001d8 0xc010e37f 0x00000000
    kern/debug/panic.c:28: __panic+105
ebp:0xc038bfe8 eip:0xc010a352 args:0x00000000 0x00000000 0x00000000 0x00000010
    kern/process/proc.c:472: do_exit+91
Welcome to the kernel debug monitor!!


zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ objdump -d obj/__user_divzero.out |grep 800f9e -C 20


00800f91 <main>:
  800f91:       55                      push   %ebp
  800f92:       89 e5                   mov    %esp,%ebp
  800f94:       83 e4 f0                and    $0xfffffff0,%esp
  800f97:       83 ec 10                sub    $0x10,%esp
  800f9a:       8b 0d 08 20 80 00       mov    0x802008,%ecx
  800fa0:       b8 01 00 00 00          mov    $0x1,%eax
  800fa5:       99                      cltd
  800fa6:       f7 f9                   idiv   %ecx             0x00800fa6
  800fa8:       89 44 24 04             mov    %eax,0x4(%esp)
  800fac:       c7 04 24 c0 12 80 00    movl   $0x8012c0,(%esp)
  800fb3:       e8 60 f1 ff ff          call   800118 <cprintf>


zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ readelf -a obj/__user_divzero.out|grep 802008 -C 10
  Size of section headers:           40 (bytes)
  Number of section headers:         11
  Section header string table index: 8

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al

  [ 4] .bss              NOBITS          00802008 007008 000004 00  WA  0   0  4

Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
--
There are no relocations in this file.

The decoding of unwind sections for machine type Intel 80386 is not currently supported.

Symbol table '.symtab' contains 76 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name

     4: 00802008     0 SECTION LOCAL  DEFAULT    4
     
    64: 00802008     4 OBJECT  GLOBAL DEFAULT    4 zero         idiv   %ecx  就是除以0
zx@zx:~/2019/00_OS/02_ucore/labs/lab5$
zx@zx:~/2019/00_OS/02_ucore/labs/lab5$





--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------

softint


user_main: name = "softint", binary = "0xc01762b3", size = "30894"
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x00000000
  ecx  0x00000000
  eax  0x00000000
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000d General Protection
  err  0x00000072
  eip  0x00800f9a
  cs   0x----001b
  flag 0x00000286 PF,SF,IF,IOPL=0
  esp  0xafffff90
  ss   0x----0023
unhandled trap.



zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ objdump -d obj/__user_softint.out |grep 800f9a -C 20
  800f6c:       0f b6 c0                movzbl %al,%eax
  800f6f:       29 c2                   sub    %eax,%edx
  800f71:       89 d0                   mov    %edx,%eax
  800f73:       eb 1a                   jmp    800f8f <memcmp+0x56>
  800f75:       83 45 fc 01             addl   $0x1,-0x4(%ebp)
  800f79:       83 45 f8 01             addl   $0x1,-0x8(%ebp)
  800f7d:       8b 45 10                mov    0x10(%ebp),%eax
  800f80:       8d 50 ff                lea    -0x1(%eax),%edx
  800f83:       89 55 10                mov    %edx,0x10(%ebp)
  800f86:       85 c0                   test   %eax,%eax
  800f88:       75 c3                   jne    800f4d <memcmp+0x14>
  800f8a:       b8 00 00 00 00          mov    $0x0,%eax
  800f8f:       c9                      leave
  800f90:       c3                      ret

00800f91 <main>:
  800f91:       55                      push   %ebp
  800f92:       89 e5                   mov    %esp,%ebp
  800f94:       83 e4 f0                and    $0xfffffff0,%esp
  800f97:       83 ec 10                sub    $0x10,%esp
  800f9a:       cd 0e                   int    $0xe                     0x00800f9a 执行 14号中断，缺页中断
  800f9c:       c7 44 24 08 a0 12 80    movl   $0x8012a0,0x8(%esp)
  800fa3:       00
  800fa4:       c7 44 24 04 07 00 00    movl   $0x7,0x4(%esp)
  800fab:       00
  800fac:       c7 04 24 ab 12 80 00    movl   $0x8012ab,(%esp)
  800fb3:       e8 77 f0 ff ff          call   80002f <__panic>




【Q】

这些err是怎么来的？含义是什么
trap 0x0000000d General Protection
err  0x00000072


Selector Error Code

 31         16   15         3   2   1   0
+---+--  --+---+---+--  --+---+---+---+---+
|   Reserved   |    Index     |  Tbl  | E |
+---+--  --+---+---+--  --+---+---+---+---+
Length  Name    Description
E   1 bit   External    When set, the exception originated externally to the processor.
Tbl 2 bits  IDT/GDT/LDT table   This is one of the following values:
Value   Description
0b00    The Selector Index references a descriptor in the GDT.
0b01    The Selector Index references a descriptor in the IDT.
0b10    The Selector Index references a descriptor in the LDT.
0b11    The Selector Index references a descriptor in the IDT.
Index   13 bits Selector Index  The index in the GDT, IDT or LDT.



        'trap 0x0000000d General Protection'                    \
        '  err  0x00000072'  

当发生General Protection时，如果和段有关系，那么会在错误码中设置段索引号
否则，错误码是0
错误码不是0，是 0x00000072    1110010
E       0       
Tbl     01    Index表示的是IDT索引
Index   1110        14  IDT索引


softint测试用例中，想进行
asm volatile("int $14");

这样看，都是14，倒是很清楚了。
是中断索引14出了问题。

【！！！】
在用户空间是不可以主动触发 int 14的
只能通过int 0x80 主动触发编号0x80的中断

其他触发都可能不是用户主动的，可能是被动触发的，比如运行过程中的缺页，内核会自己触发
或者用户代码中 除以0等


--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------

faultread

user_main: name = "faultread", binary = "0xc0148e4a", size = "30896"
not valid addr 0, and  can not find it in vma
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x00000000
  ecx  0x00000000
  eax  0x00000000
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000e Page Fault
  err  0x00000004
  eip  0x00800f9f
  cs   0x----001b
  flag 0x00000286 PF,SF,IF,IOPL=0
  esp  0xafffff90
  ss   0x----0023
killed by kernel.
kernel panic at kern/trap/trap.c:220:
    handle user mode pgfault failed. ret=-3

stack trackback:
ebp:0xc0392f08 eip:0xc0100aeb args:0xc010c564 0xc0392f4c 0x000000dc 0xc0392f50
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc0392f38 eip:0xc0100e4b args:0xc010c910 0x000000dc 0xc010c99c 0xfffffffd
    kern/debug/panic.c:28: __panic+105
ebp:0xc0392f78 eip:0xc0102957 args:0xc0392fb4 0x00000000 0x00800020 0x0000001b
    kern/trap/trap.c:220: trap_dispatch+292
ebp:0xc0392fa8 eip:0xc0102b93 args:0xc0392fb4 0x00000000 0x00000000 0xafffffa8
    kern/trap/trap.c:319: trap+74
ebp:0xafffffa8 eip:0xc0102be8 args:0x00000000 0x00000000 0x00000000 0x00000000
    kern/trap/trapentry.S:24: <unknown>+0
ebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000
    user/libs/umain.c:7: umain+10
Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.
K> qemu: terminating on signal 2



zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ objdump -d obj/__user_faultread.out |grep 800f9f -C 20


00800f91 <main>:
  800f91:       55                      push   %ebp
  800f92:       89 e5                   mov    %esp,%ebp
  800f94:       83 e4 f0                and    $0xfffffff0,%esp
  800f97:       83 ec 10                sub    $0x10,%esp
  800f9a:       b8 00 00 00 00          mov    $0x0,%eax
  800f9f:       8b 00                   mov    (%eax),%eax                  0x00800f9f
  800fa1:       89 44 24 04             mov    %eax,0x4(%esp)
  800fa5:       c7 04 24 c0 12 80 00    movl   $0x8012c0,(%esp)
  800fac:       e8 67 f1 ff ff          call   800118 <cprintf>
  800fb1:       c7 44 24 08 d4 12 80    movl   $0x8012d4,0x8(%esp)
  800fb8:       00
  800fb9:       c7 44 24 04 07 00 00    movl   $0x7,0x4(%esp)
  800fc0:       00
  800fc1:       c7 04 24 df 12 80 00    movl   $0x8012df,(%esp)
  800fc8:       e8 62 f0 ff ff          call   80002f <__panic>
zx@zx:~/2019/00_OS/02_ucore/labs/lab5$
zx@zx:~/2019/00_OS/02_ucore/labs/lab5$



【Q】
trap 0x0000000e Page Fault
err  0x00000004

bit 0 == 0 means no page found, 1 means protection fault
bit 1 == 0 means read, 1 means write
bit 2 == 0 means kernel, 1 means user

0x00000004      user   read     no page found



vmm研究


pgfault_handler     运行完 mm = current->mm; 这一行
(gdb) p/x *mm
$2 = {mmap_list = {prev = 0xc0389238, next = 0xc03891d8}, mmap_cache = 0x0, pgdir = 0xc0393000, map_count = 0x4, sm_priv = 0xc01a91cc, mm_count = 0x1, mm_lock = 0x0}
(gdb) p/x (list_entry_t*)0xc03891d8
$3 = 0xc03891d8
(gdb) p/x *((list_entry_t*)0xc03891d8)
$4 = {prev = 0xc03891a0, next = 0xc03891f8}
(gdb) p/x *((list_entry_t*)0xc03891f8)
$5 = {prev = 0xc03891d8, next = 0xc0389218}
(gdb) p/x *((list_entry_t*)0xc0389218)
$6 = {prev = 0xc03891f8, next = 0xc0389238}
(gdb) p/x *((list_entry_t*)0xc0389238)
$7 = {prev = 0xc0389218, next = 0xc03891a0}
(gdb) p/x *((list_entry_t*)0xc03891a0)
$8 = {prev = 0xc0389238, next = 0xc03891d8}
(gdb) p/x *((list_entry_t*)0xc03891d8)
$9 = {prev = 0xc03891a0, next = 0xc03891f8}
(gdb) p/x *((list_entry_t*)0xc03891f8)
$10 = {prev = 0xc03891d8, next = 0xc0389218}
(gdb) p/x &mm->mmap_list
$12 = 0xc03891a0



0xc03891a0          0xc03891d8  0xc03891f8  0xc0389218  0xc0389238

(gdb) p/x *((int*)(0xc03891d8-0xc))
$13 = 0x200000
(gdb) p/x *((int*)(0xc03891d8-0x8))
$14 = 0x204000

(gdb) p/x *((int*)(0xc03891f8-0xc))
$15 = 0x800000
(gdb) p/x *((int*)(0xc03891f8-0x8))
$16 = 0x802000

(gdb) p/x *((int*)(0xc0389218-0xc))
$17 = 0x802000
(gdb) p/x *((int*)(0xc0389218-0x8))
$18 = 0x803000

(gdb) p/x *((int*)(0xc0389238-0xc))
$19 = 0xaff00000
(gdb) p/x *((int*)(0xc0389238-0x8))
$20 = 0xb0000000




zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ readelf -a obj/__user_faultread.out
ld链接脚本中，都规定是按照 1页对齐的  
  
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00800020 005020 001034 00  AX  0   0  1
  [ 2] .rodata           PROGBITS        00801060 006060 000398 00   A  0   0 32
  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8
  [ 4] .stab_info        PROGBITS        00200000 001000 000010 00  WA  0   0  1
  [ 5] .stab             PROGBITS        00200010 001010 002ab5 0c   A  6   0  4
  [ 6] .stabstr          STRTAB          00202ac5 003ac5 000f9a 00   A  0   0  1
  [ 7] .shstrtab         STRTAB          00000000 007008 000049 00      0   0  1
  [ 8] .symtab           SYMTAB          00000000 0071e4 0004a0 10      9  26  4
  [ 9] .strtab           STRTAB          00000000 007684 00022c 00      0   0  1
  
  
  
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 4] .stab_info        PROGBITS        00200000 001000 000010 00  WA  0   0  1
  [ 5] .stab             PROGBITS        00200010 001010 002ab5 0c   A  6   0  4
  [ 6] .stabstr          STRTAB          00202ac5 003ac5 000f9a 00   A  0   0  1
  
  [ 1] .text             PROGBITS        00800020 005020 001034 00  AX  0   0  1
  
  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8

  
  
（1）  
(gdb) p/x *((int*)(0xc03891d8-0xc))
$13 = 0x200000
(gdb) p/x *((int*)(0xc03891d8-0x8))
$14 = 0x204000

  [ 4] .stab_info        PROGBITS        00200000 001000 000010 00  WA  0   0  1
  [ 5] .stab             PROGBITS        00200010 001010 002ab5 0c   A  6   0  4
  [ 6] .stabstr          STRTAB          00202ac5 003ac5 000f9a 00   A  0   0  1

  
（2） 
(gdb) p/x *((int*)(0xc03891f8-0xc))
$15 = 0x800000
(gdb) p/x *((int*)(0xc03891f8-0x8))
$16 = 0x802000  
  
  [ 1] .text             PROGBITS        00800020 005020 001034 00  AX  0   0  1
  [ 2] .rodata           PROGBITS        00801060 006060 000398 00   A  0   0 32

  [ 2] .rodata           PROGBITS        00801060 006060 000398 00   A  0   0 32
   Num:    Value  Size Type    Bind   Vis      Ndx Name
    16: 00801160   100 OBJECT  LOCAL  DEFAULT    2 error_string
    
感觉像是只读数据，static const char * const error_string[MAXERROR + 1] = {
    [0]                     NULL,
    [E_UNSPECIFIED]         "unspecified error",
。。。 
    

    
（3） 
(gdb) p/x *((int*)(0xc0389218-0xc))
$17 = 0x802000
(gdb) p/x *((int*)(0xc0389218-0x8))
$18 = 0x803000

  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8
  

  
（4）
(gdb) p/x *((int*)(0xc0389238-0xc))
$19 = 0xaff00000
(gdb) p/x *((int*)(0xc0389238-0x8))
$20 = 0xb0000000
  
  看来只有 0xaff00000-0xb0000000 是可用的

所以测试代码中：

    cprintf("I read %8x from -4.\n", *(unsigned int *)(0xB0000000 - 4));
    cprintf("I read %8x from -8.\n", *(unsigned int *)(0xB0000000 - 8));//user stack

    
    cprintf("I read %8x from 0x802000+8.\n", *(unsigned int *)(0x802000 + 8));//data
    cprintf("I read %8x from 0x802000-8.\n", *(unsigned int *)(0x802000 - 8));//text or rodata

    cprintf("I read %8x from 0x200000 + 8.\n", *(unsigned int *)(0x200000 + 8));//stab...

    cprintf("I read %8x from 0xc0392fb4-8.\n", *(unsigned int *)(0xc0392fb4 - 8));//tf, can not


    struct user_trapframe* utf = (struct user_trapframe*)0xc0392fb4;
    cprintf("I read %8x from tf.tf_cs.\n", utf->tf_cs);
    cprintf("I read %8x from tf.tf_ds.\n", utf->tf_ds);
    cprintf("I read %8x from tf.tf_ss.\n", utf->tf_ss);

    
kernel_execve: pid = 2, name = "faultread".
user_main: name = "faultread", binary = "0xc0148e4a", size = "30896"
I read        0 from -4.
I read        0 from -8.
I read        0 from 0x802000+8.
I read        0 from 0x802000-8.
I read   202ae9 from 0x200000 + 8.
not valid addr c0392fac, and  can not find it in vma
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x00801403
  ecx  0xaffffec8
  eax  0xc0392fac
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000e Page Fault
  err  0x00000005
  eip  0x00801012
  cs   0x----001b
  flag 0x00000282 SF,IF,IOPL=0
  esp  0xafffff80
  ss   0x----0023
killed by kernel.
kernel panic at kern/trap/trap.c:220:
    handle user mode pgfault failed. ret=-3

stack trackback:
ebp:0xc0392f08 eip:0xc0100aeb args:0xc010c564 0xc0392f4c 0x000000dc 0x008000d6
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc0392f38 eip:0xc0100e4b args:0xc010c910 0x000000dc 0xc010c99c 0xfffffffd
    kern/debug/panic.c:28: __panic+105
ebp:0xc0392f78 eip:0xc0102957 args:0xc0392fb4 0x00000000 0x00800020 0x0000001b
    kern/trap/trap.c:220: trap_dispatch+292
ebp:0xc0392fa8 eip:0xc0102b93 args:0xc0392fb4 0x00000000 0x00000000 0xafffffa8
    kern/trap/trap.c:319: trap+74
ebp:0xafffffa8 eip:0xc0102be8 args:0x00000000 0x00000000 0x00000000 0x00000000
    kern/trap/trapentry.S:24: <unknown>+0
ebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000
    user/libs/umain.c:7: umain+10
Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.
K> qemu: terminating on signal 2

  
只有在 0xaff00000-0xb0000000 的 addr（这是缺页的地址，通过cr2获取）  才能访问到对应的vma

否则 在 do_pgfault 中  struct vma_struct *vma = find_vma(mm, addr);
时，   find的结果肯定是空的，不能进行下一步

-----------------------------------

符号表没有对应的：

  [ 7] .shstrtab         STRTAB          00000000 007008 000049 00      0   0  1
  [ 8] .symtab           SYMTAB          00000000 0071e4 0004a0 10      9  26  4
  [ 9] .strtab           STRTAB          00000000 007684 00022c 00      0   0  1


  
目前能确定这些vma是在 load_icode中调用 mm_map 创建的

readelf打印的是未经页对齐处理的，是真正的起始地址。
vma打印出来的 start 和stop 是经过页对齐处理过的。
  start 是 page down 对齐
  stop 是page up 对齐
  
  
---------------------------------------------------------------------------------------------------  

这一段描述了一些 程序段的分类
00~03总共是4种，在load_icode中可以看到 总共是4个vma
就是下面4个
  
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x001000 0x00200000 0x00200000 0x03a5f 0x03a5f RW  0x1000          stab
  LOAD           0x005020 0x00800020 0x00800020 0x013d8 0x013d8 R E 0x1000          text rodata
  LOAD           0x007000 0x00802000 0x00802000 0x00008 0x00008 RW  0x1000          data
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10            ustack

 Section to Segment mapping:
  Segment Sections...
   00     .stab_info .stab .stabstr
   01     .text .rodata
   02     .data
   03

                    vma start       vma end
stab                0x200000        0x204000
text rodata         0x800000        0x802000
data                0x802000        0x803000
ustack              0xaff00000      0xb0000000
   
   
   
   
There is no dynamic section in this file.

There are no relocations in this file.

The decoding of unwind sections for machine type Intel 80386 is not currently supported.

Symbol table '.symtab' contains 74 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00800020     0 SECTION LOCAL  DEFAULT    1
     2: 00801060     0 SECTION LOCAL  DEFAULT    2
     3: 00802000     0 SECTION LOCAL  DEFAULT    3
     4: 00200000     0 SECTION LOCAL  DEFAULT    4
     5: 00200010     0 SECTION LOCAL  DEFAULT    5
     6: 00202ac5     0 SECTION LOCAL  DEFAULT    6
     7: 00000000     0 FILE    LOCAL  DEFAULT  ABS panic.c
     8: 00000000     0 FILE    LOCAL  DEFAULT  ABS stdio.c
     9: 008000c5    32 FUNC    LOCAL  DEFAULT    1 cputch
    10: 00000000     0 FILE    LOCAL  DEFAULT  ABS syscall.c
    11: 0080018d    86 FUNC    LOCAL  DEFAULT    1 syscall
    12: 00000000     0 FILE    LOCAL  DEFAULT  ABS ulib.c
    13: 00000000     0 FILE    LOCAL  DEFAULT  ABS umain.c
    14: 00000000     0 FILE    LOCAL  DEFAULT  ABS hash.c
    15: 00000000     0 FILE    LOCAL  DEFAULT  ABS printfmt.c
    16: 00801160   100 OBJECT  LOCAL  DEFAULT    2 error_string
    17: 00800380   261 FUNC    LOCAL  DEFAULT    1 printnum
    18: 00800485    79 FUNC    LOCAL  DEFAULT    1 getuint
    19: 008004d4    71 FUNC    LOCAL  DEFAULT    1 getint
    20: 00800934    53 FUNC    LOCAL  DEFAULT    1 sprintputch
    21: 00000000     0 FILE    LOCAL  DEFAULT  ABS rand.c
    22: 00802000     8 OBJECT  LOCAL  DEFAULT    3 next
    23: 00000000     0 FILE    LOCAL  DEFAULT  ABS string.c
    24: 00000000     0 FILE    LOCAL  DEFAULT  ABS faultread.c
    25: 00000000     0 FILE    LOCAL  DEFAULT  ABS
    26: 00800b31    63 FUNC    GLOBAL DEFAULT    1 strcpy
    27: 00800308    13 FUNC    GLOBAL DEFAULT    1 yield
    28: 008002ee    26 FUNC    GLOBAL DEFAULT    1 waitpid
    29: 00800234    20 FUNC    GLOBAL DEFAULT    1 sys_yield
    30: 00800e47   163 FUNC    GLOBAL DEFAULT    1 memmove
    31: 00800969    52 FUNC    GLOBAL DEFAULT    1 snprintf
    32: 00800549  1003 FUNC    GLOBAL DEFAULT    1 vprintfmt
    33: 008001fe    20 FUNC    GLOBAL DEFAULT    1 sys_fork
    34: 00800118    38 FUNC    GLOBAL DEFAULT    1 cprintf
    35: 00800328    13 FUNC    GLOBAL DEFAULT    1 getpid
    36: 00800eea    79 FUNC    GLOBAL DEFAULT    1 memcpy
    37: 0080099d   100 FUNC    GLOBAL DEFAULT    1 vsnprintf
    38: 00800342    25 FUNC    GLOBAL DEFAULT    1 umain
    39: 00202ac4     0 NOTYPE  GLOBAL DEFAULT    5 __STAB_END__
    40: 00800248    27 FUNC    GLOBAL DEFAULT    1 sys_kill
    41: 00202ac5     0 NOTYPE  GLOBAL DEFAULT    6 __STABSTR_BEGIN__
    42: 0080002f    80 FUNC    GLOBAL DEFAULT    1 __panic
    43: 00800caa   350 FUNC    GLOBAL DEFAULT    1 strtol
    44: 00800b01    48 FUNC    GLOBAL DEFAULT    1 strnlen
    45: 00800335    13 FUNC    GLOBAL DEFAULT    1 print_pgdir
    46: 00800315    19 FUNC    GLOBAL DEFAULT    1 kill
    47: 00800c7c    46 FUNC    GLOBAL DEFAULT    1 strfind
    48: 008002d2    28 FUNC    GLOBAL DEFAULT    1 wait
    49: 00800020     0 NOTYPE  GLOBAL DEFAULT    1 _start
    50: 00800a01   192 FUNC    GLOBAL DEFAULT    1 rand
    51: 00800bf3    86 FUNC    GLOBAL DEFAULT    1 strncmp
    52: 00800277    27 FUNC    GLOBAL DEFAULT    1 sys_putc
    53: 00800b70    58 FUNC    GLOBAL DEFAULT    1 strncpy
    54: 00800f39    88 FUNC    GLOBAL DEFAULT    1 memcmp
    55: 008002c5    13 FUNC    GLOBAL DEFAULT    1 fork
    56: 00800e08    63 FUNC    GLOBAL DEFAULT    1 memset
    57: 00800f91   195 FUNC    GLOBAL DEFAULT    1 main
    58: 00800ac1    24 FUNC    GLOBAL DEFAULT    1 srand
    59: 0080035b    37 FUNC    GLOBAL DEFAULT    1 hash32
    60: 0080051b    46 FUNC    GLOBAL DEFAULT    1 printfmt
    61: 00203a5e     0 NOTYPE  GLOBAL DEFAULT    6 __STABSTR_END__
    62: 00800baa    73 FUNC    GLOBAL DEFAULT    1 strcmp
    63: 008000e5    51 FUNC    GLOBAL DEFAULT    1 vcprintf
    64: 0080007f    70 FUNC    GLOBAL DEFAULT    1 __warn
    65: 0080013e    79 FUNC    GLOBAL DEFAULT    1 cputs
    66: 008002a6    31 FUNC    GLOBAL DEFAULT    1 exit
    67: 00800212    34 FUNC    GLOBAL DEFAULT    1 sys_wait
    68: 008001e3    27 FUNC    GLOBAL DEFAULT    1 sys_exit
    69: 00200010     0 NOTYPE  GLOBAL DEFAULT    5 __STAB_BEGIN__
    70: 00800ad9    40 FUNC    GLOBAL DEFAULT    1 strlen
    71: 00800292    20 FUNC    GLOBAL DEFAULT    1 sys_pgdir
    72: 00800c49    51 FUNC    GLOBAL DEFAULT    1 strchr
    73: 00800263    20 FUNC    GLOBAL DEFAULT    1 sys_getpid
  
  



--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------

faultreadkernel

kernel_execve: pid = 2, name = "faultreadkernel".
user_main: name = "faultreadkernel", binary = "0xc01506fa", size = "30902"
not valid addr fac00000, and  can not find it in vma
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x00000000
  ecx  0x00000000
  eax  0xfac00000
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000e Page Fault
  err  0x00000005
  eip  0x00800f9f
  cs   0x----001b
  flag 0x00000286 PF,SF,IF,IOPL=0
  esp  0xafffff90
  ss   0x----0023
killed by kernel.
kernel panic at kern/trap/trap.c:220:
    handle user mode pgfault failed. ret=-3


----

addr            err                 offset
fabffffc        0x00000004          fac00000 - 4

------------------------------------------------------------------------
fac00000        0x00000005
fac00004        0x00000005          fac00000 + 4

fac00ffc        0x00000005          fac00000 + 1023 * 4

----
fac01000        0x00000004          fac00000 + 1024 * 4



fac02000        0x00000005          fac00000 + 2* 1024 * 4


fac03000        0x00000004



fafeaffc        0x00000004          fafeb000 - 4
fafeb000        0x00000005
fafeb004        0x00000005          fafeb000 + 4





fafffffc        0x00000004          fb000000 - 4
------------------------------------------------------------------------

fb000000        0x00000004
fb000004        0x00000004          fb000000 + 4










【Q】
（1）0xfac00000
trap 0x0000000e Page Fault
err  0x00000005

bit 0 == 0 means no page found, 1 means protection fault
bit 1 == 0 means read, 1 means write
bit 2 == 0 means kernel, 1 means user

0x00000005      user   read     protection fault    用户态访问受限



（2）0xc0392fac
not valid addr c0392fac, and  can not find it in vma
trapframe at 0xc0392fb4

  trap 0x0000000e Page Fault
  err  0x00000005

0xc0392fb4      user   read     protection fault    用户态访问受限

（3）0x0
trap 0x0000000e Page Fault
err  0x00000004

bit 0 == 0 means no page found, 1 means protection fault
bit 1 == 0 means read, 1 means write
bit 2 == 0 means kernel, 1 means user

0x00000004      user   read     no page found   确实是缺页



void page_fault(pt_regs *regs)
{
    uint32_t cr2;
    asm volatile ("mov %%cr2, %0" : "=r" (cr2));

    printk("Page fault at EIP: 0x%x, virtual faulting address 0x%x\n", regs->eip, cr2);
    printk("Error code: %x\n", regs->err_code);

    // bit 0 为 0 指页面不存在内存里
    if ( !(regs->err_code & 0x1)) {
        printk_color(rc_black, rc_red, "Because the page wasn't present.\n");
    }
    // bit 1 为 0 表示读错误，为 1 为写错误
    if (regs->err_code & 0x2) {
        printk_color(rc_black, rc_red, "Write error.\n");
    } else {
        printk_color(rc_black, rc_red, "Read error.\n");
    }
    // bit 2 为 1 表示在用户模式打断的，为 0 是在内核模式打断的
    if (regs->err_code & 0x4) {
        printk_color(rc_black, rc_red, "In user mode.\n");
    } else {
        printk_color(rc_black, rc_red, "In kernel mode.\n");
    }
    // bit 3 为 1 表示错误是由保留位覆盖造成的
    if (regs->err_code & 0x8) {
        printk_color(rc_black, rc_red, "Reserved bits being overwritten.\n");
    }
    // bit 4 为 1 表示错误发生在取指令的时候
    if (regs->err_code & 0x10) {
        printk_color(rc_black, rc_red, "The fault occurred during an instruction fetch.\n");
    }

    while (1);
}


trap 0x0000000e Page Fault 发生时，会设置err的值，表示到底是什么原因造成的
对于bit 0，有两种可能， 
0：表示需要访问的页是没有与物理内存进行映射的，需要在服务例程中进行物理页的分配和映射，也可能会有swap
1：表示有对物理内存的映射，但是目前是不能访问的，也就是发生了 protection violation，可能是在用户态是不允许访问的






--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------


hello

见 lab5中记录的对3rd的创建和运行记录



--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------

testbss


kernel_execve: pid = 2, name = "testbss".
user_main: name = "testbss", binary = "0xc018540c", size = "30979"
Making sure bss works right...
Yes, good.  Now doing a wild write off the end...
testbss may pass.
bigarray arrd: 0x802020
not valid addr c03020, and  can not find it in vma
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x0080146d
  ecx  0xaffffec8
  eax  0x00000018
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000e Page Fault
  err  0x00000006
  eip  0x00801096
  cs   0x----001b
  flag 0x00000282 SF,IF,IOPL=0
  esp  0xafffff80
  ss   0x----0023
killed by kernel.
kernel panic at kern/trap/trap.c:220:
    handle user mode pgfault failed. ret=-3

stack trackback:
ebp:0xc0392f08 eip:0xc0100aeb args:0xc010c564 0xc0392f4c 0x000000dc 0x008000d6
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc0392f38 eip:0xc0100e4b args:0xc010c910 0x000000dc 0xc010c99c 0xfffffffd
    kern/debug/panic.c:28: __panic+105
ebp:0xc0392f78 eip:0xc0102957 args:0xc0392fb4 0x00000000 0x00800020 0x0000001b
    kern/trap/trap.c:220: trap_dispatch+292
ebp:0xc0392fa8 eip:0xc0102b93 args:0xc0392fb4 0x00000000 0x00000000 0xafffffa8
    kern/trap/trap.c:319: trap+74
ebp:0xafffffa8 eip:0xc0102be8 args:0x00000000 0x00000000 0x00000000 0x00000000
    kern/trap/trapentry.S:24: <unknown>+0
ebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000
    user/libs/umain.c:7: umain+10
Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.



objdump -d obj/__user_testbss.out |grep 801096 -C 100
00800f91 <main>:

  80108a:       c7 04 24 5a 14 80 00    movl   $0x80145a,(%esp)
  801091:       e8 82 f0 ff ff          call   800118 <cprintf>
  801096:       c7 05 20 30 c0 00 00    movl   $0x0,0xc03020            0x00801096
  80109d:       00 00 00
  8010a0:       cd 14                   int    $0x14


结合 not valid addr c03020
这个地址是什么？
  
  

vmm研究
  
(gdb) p/x mm
$1 = 0xc03891a0
(gdb) p/x &mm->mmap_list
$2 = 0xc03891a0
(gdb) print_mm_vmas_details mm
list header: 0xc03891a0
le: 0xc03891d8          vma: 0xc03891c8         vm_start: 0x200000              vm_end: 0x204000                vm_flags: 0x3
le: 0xc03891f8          vma: 0xc03891e8         vm_start: 0x800000              vm_end: 0x802000                vm_flags: 0x5
le: 0xc0389218          vma: 0xc0389208         vm_start: 0x802000              vm_end: 0xc03000                vm_flags: 0x3
le: 0xc0389238          vma: 0xc0389228         vm_start: 0xaff00000            vm_end: 0xb0000000              vm_flags: 0xb
list header: 0xc03891a0


zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ readelf -a obj/__user_testbss.out
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x800020
  Start of program headers:          52 (bytes into file)
  Start of section headers:          28760 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         4
  Size of section headers:           40 (bytes)
  Number of section headers:         11
  Section header string table index: 8

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00800020 005020 00109e 00  AX  0   0  1
  [ 2] .rodata           PROGBITS        008010c0 0060c0 0003b8 00   A  0   0 32
  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8
  [ 4] .bss              NOBITS          00802020 007008 400000 00  WA  0   0 32        这玩意就是 bigarray  全零，看看是不是需要占400000这么大空间？
  [ 5] .stab_info        PROGBITS        00200000 001000 000010 00  WA  0   0  1
  [ 6] .stab             PROGBITS        00200010 001010 002b45 0c   A  7   0  4
  [ 7] .stabstr          STRTAB          00202b55 003b55 000d61 00   A  0   0  1
  [ 8] .shstrtab         STRTAB          00000000 007008 00004e 00      0   0  1
  [ 9] .symtab           SYMTAB          00000000 007210 0004c0 10     10  27  4
  [10] .strtab           STRTAB          00000000 0076d0 000233 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

There are no section groups in this file.




（1）
vm_start: 0x200000              vm_end: 0x204000  
  [ 5] .stab_info        PROGBITS        00200000 001000 000010 00  WA  0   0  1
  [ 6] .stab             PROGBITS        00200010 001010 002b45 0c   A  7   0  4
  [ 7] .stabstr          STRTAB          00202b55 003b55 000d61 00   A  0   0  1

（2）  
vm_start: 0x800000              vm_end: 0x802000  
  [ 1] .text             PROGBITS        00800020 005020 00109e 00  AX  0   0  1
  [ 2] .rodata           PROGBITS        008010c0 0060c0 0003b8 00   A  0   0 32

（3）
vm_start: 0x802000              vm_end: 0xc03000  
  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8
  [ 4] .bss              NOBITS          00802020 007008 400000 00  WA  0   0 32

可以看到在虚拟内存中，确实为bss分配了虚拟空间


这一段的真实结束地址应该是 0x00C02020
但是通过vm_end可以看到 其实是 0xc03000
就是ROUNDUP造成的


0xc03000 - 0x00C02020 = 4064
4064 / 4 = 1016
1024 - 1016 = 8

  
（4）
vm_start: 0xaff00000            vm_end: 0xb0000000
  看来只有 0xaff00000-0xb0000000 是可用的



【Q】
结合 not valid addr c03020
这个地址是什么？
vm_end: 0xc03000    
c03020 - 0xc03000 = 0x20



    //bigarray[ARRAYSIZE + 1024] = 0;    //c03020
    //bigarray[ARRAYSIZE + 1024 - 1] = 0;//c0301c
    //...
    //bigarray[ARRAYSIZE + 1024 - 2] = 0;//c03018
    //bigarray[ARRAYSIZE + 1024 - 7] = 0;//c03004
    //bigarray[ARRAYSIZE + 1024 - 8] = 0;//c03000

    
    //bigarray[ARRAYSIZE] = 0;//can not test the issue of out of memory
    //bigarray[ARRAYSIZE + 1] = 0;
    //bigarray[ARRAYSIZE + 2] = 0;
    //bigarray[ARRAYSIZE + 512] = 0;
    bigarray[ARRAYSIZE + 1024 - 9] = 0;//can not test the issue of out of memory  

【！！！】
所以也可以确定一件事就是 out of memory的问题，有时候不是只要一越界就能检测到的
可能是需要越界到一定程度以后，才会有反应
并不是越了 1 个单位，就立马能检测到


  [ 4] .bss              NOBITS          00802020 007008 400000 00  WA  0   0 32

0x00802020 + 0x00400000 = 0x00C02020
.bss虚拟地址是 00802020 ~ C02020     不包括 C02020
  
#define ARRAYSIZE (1024*1024)

bigarray[ARRAYSIZE - 1]         00802020 + 4 * (1024 * 1024 - 1) =  C0201C

bigarray[ARRAYSIZE]             00802020 + 4 * (1024 * 1024)     =  C02020
bigarray[ARRAYSIZE + 1]         00802020 + 4 * (1024 * 1024 + 1) =  C02024
bigarray[ARRAYSIZE + 1024]      00802020 + 4 * (1024*1024 + 1024) = C03020

所以C03020 这个地址是 bigarray[ARRAYSIZE + 1024] 需要访问的地址

这个地址超出了bss段的虚拟地址的范围，所以
在 do_pgfault 中  struct vma_struct *vma = find_vma(mm, addr);
时，   find的结果肯定是空的，不能进行下一步


C02020 + 4K = C03020
C02000 + 4K = C03000

【！！！】那么为何会有这种越界后没有立马检测到的情况呢？

load_icode中使用 mm_map建立vma
会进行start的ROUNDDOWN 和 end的 ROUNDUP
所以 第三个vma会 vm_start: 0x802000  vm_end: 0xc03000  
包括了data和bss。

  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8
  [ 4] .bss              NOBITS          00802020 007008 400000 00  WA  0   0 32
而不经过ROUNDDOWN ROUNDUP处理的这段虚拟地址 是到 0x00C02020 结束的
所以这样看，仅仅从 find_vma的角度看
小于vm_end: 0xc03000  的都是可以find到的

所以
bigarray[ARRAYSIZE + 1024 - 9]   00802020 + 4 * (1024*1024 + 1024 - 9) = C02FFC < 0xc03000
这样就不会被检测到

bigarray[ARRAYSIZE + 1024 - 8]   00802020 + 4 * (1024*1024 + 1024 - 8) = c03000 = 0xc03000
这个会被检测到，因为不包含 0xc03000

所以 大于 ARRAYSIZE + 1024 - 8 的索引，都会被检测到
这就是 end的 ROUNDUP造成的


这样看的话 ROUNDDOWN 也会导致 一些 负的 索引有问题 【？？？？？？Q】


ROUNDDOWN 和 ROUNDUP 造成了 虚拟地址空间 都会和原始的不一致，
ROUNDDOWN 后小于等于 原始start， ROUNDUP后大于等于 原始 end
造成了虚拟空间的扩大
会导致 真实虚拟地址 两头的一部分地址被包括到 分配给vma的虚拟地址空间中，扩大了地址范围
两头都在1页之内。


也可以这样看问题
这一段的真实结束地址应该是 0x00C02020
但是通过vm_end可以看到 其实是 0xc03000
就是ROUNDUP造成的
0xc03000 - 0x00C02020 = 4064
4064 / 4 = 1016
1024 - 1016 = 8


所以假设如果该bss在vma中正好以4K对齐的地址结尾，那么一越界就应该能检测到的【证明在下面的Q】

----------------------------------------------------------

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x001000 0x00200000 0x00200000 0x038b6 0x038b6 RW  0x1000          stab
  LOAD           0x005020 0x00800020 0x00800020 0x01458 0x01458 R E 0x1000          text  rodata
  LOAD           0x007000 0x00802000 0x00802000 0x00008 0x400020 RW  0x1000         data
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10            ustack

 Section to Segment mapping:
  Segment Sections...
   00     .stab_info .stab .stabstr
   01     .text .rodata
   02     .data .bss                    和 faultread 对比，多了一个bss段
   03

There is no dynamic section in this file.

There are no relocations in this file.

The decoding of unwind sections for machine type Intel 80386 is not currently supported.

Symbol table '.symtab' contains 76 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00800020     0 SECTION LOCAL  DEFAULT    1
     2: 008010c0     0 SECTION LOCAL  DEFAULT    2
     3: 00802000     0 SECTION LOCAL  DEFAULT    3
     4: 00802020     0 SECTION LOCAL  DEFAULT    4
     5: 00200000     0 SECTION LOCAL  DEFAULT    5
     6: 00200010     0 SECTION LOCAL  DEFAULT    6
     7: 00202b55     0 SECTION LOCAL  DEFAULT    7
     8: 00000000     0 FILE    LOCAL  DEFAULT  ABS panic.c
     9: 00000000     0 FILE    LOCAL  DEFAULT  ABS stdio.c
    10: 008000c5    32 FUNC    LOCAL  DEFAULT    1 cputch
    11: 00000000     0 FILE    LOCAL  DEFAULT  ABS syscall.c
    12: 0080018d    86 FUNC    LOCAL  DEFAULT    1 syscall
    13: 00000000     0 FILE    LOCAL  DEFAULT  ABS ulib.c
    14: 00000000     0 FILE    LOCAL  DEFAULT  ABS umain.c
    15: 00000000     0 FILE    LOCAL  DEFAULT  ABS hash.c
    16: 00000000     0 FILE    LOCAL  DEFAULT  ABS printfmt.c
    17: 008011c0   100 OBJECT  LOCAL  DEFAULT    2 error_string
    18: 00800380   261 FUNC    LOCAL  DEFAULT    1 printnum
    19: 00800485    79 FUNC    LOCAL  DEFAULT    1 getuint
    20: 008004d4    71 FUNC    LOCAL  DEFAULT    1 getint
    21: 00800934    53 FUNC    LOCAL  DEFAULT    1 sprintputch
    22: 00000000     0 FILE    LOCAL  DEFAULT  ABS rand.c
    23: 00802000     8 OBJECT  LOCAL  DEFAULT    3 next
    24: 00000000     0 FILE    LOCAL  DEFAULT  ABS string.c
    25: 00000000     0 FILE    LOCAL  DEFAULT  ABS testbss.c
    26: 00000000     0 FILE    LOCAL  DEFAULT  ABS
    27: 00800b31    63 FUNC    GLOBAL DEFAULT    1 strcpy
    28: 00800308    13 FUNC    GLOBAL DEFAULT    1 yield
    29: 008002ee    26 FUNC    GLOBAL DEFAULT    1 waitpid
    30: 00800234    20 FUNC    GLOBAL DEFAULT    1 sys_yield
    31: 00800e47   163 FUNC    GLOBAL DEFAULT    1 memmove
    32: 00800969    52 FUNC    GLOBAL DEFAULT    1 snprintf
    33: 00800549  1003 FUNC    GLOBAL DEFAULT    1 vprintfmt
    34: 008001fe    20 FUNC    GLOBAL DEFAULT    1 sys_fork
    35: 00800118    38 FUNC    GLOBAL DEFAULT    1 cprintf
    36: 00800328    13 FUNC    GLOBAL DEFAULT    1 getpid
    37: 00800eea    79 FUNC    GLOBAL DEFAULT    1 memcpy
    38: 0080099d   100 FUNC    GLOBAL DEFAULT    1 vsnprintf
    39: 00800342    25 FUNC    GLOBAL DEFAULT    1 umain
    40: 00202b54     0 NOTYPE  GLOBAL DEFAULT    6 __STAB_END__
    41: 00800248    27 FUNC    GLOBAL DEFAULT    1 sys_kill
    42: 00202b55     0 NOTYPE  GLOBAL DEFAULT    7 __STABSTR_BEGIN__
    43: 0080002f    80 FUNC    GLOBAL DEFAULT    1 __panic
    44: 00800caa   350 FUNC    GLOBAL DEFAULT    1 strtol
    45: 00800b01    48 FUNC    GLOBAL DEFAULT    1 strnlen
    46: 00802020 0x400000 OBJECT  GLOBAL DEFAULT    4 bigarray
    47: 00800335    13 FUNC    GLOBAL DEFAULT    1 print_pgdir
    48: 00800315    19 FUNC    GLOBAL DEFAULT    1 kill
    49: 00800c7c    46 FUNC    GLOBAL DEFAULT    1 strfind
    50: 008002d2    28 FUNC    GLOBAL DEFAULT    1 wait
    51: 00800020     0 NOTYPE  GLOBAL DEFAULT    1 _start
    52: 00800a01   192 FUNC    GLOBAL DEFAULT    1 rand
    53: 00800bf3    86 FUNC    GLOBAL DEFAULT    1 strncmp
    54: 00800277    27 FUNC    GLOBAL DEFAULT    1 sys_putc
    55: 00800b70    58 FUNC    GLOBAL DEFAULT    1 strncpy
    56: 00800f39    88 FUNC    GLOBAL DEFAULT    1 memcmp
    57: 008002c5    13 FUNC    GLOBAL DEFAULT    1 fork
    58: 00800e08    63 FUNC    GLOBAL DEFAULT    1 memset
    59: 00800f91   301 FUNC    GLOBAL DEFAULT    1 main
    60: 00800ac1    24 FUNC    GLOBAL DEFAULT    1 srand
    61: 0080035b    37 FUNC    GLOBAL DEFAULT    1 hash32
    62: 0080051b    46 FUNC    GLOBAL DEFAULT    1 printfmt
    63: 002038b5     0 NOTYPE  GLOBAL DEFAULT    7 __STABSTR_END__
    64: 00800baa    73 FUNC    GLOBAL DEFAULT    1 strcmp
    65: 008000e5    51 FUNC    GLOBAL DEFAULT    1 vcprintf
    66: 0080007f    70 FUNC    GLOBAL DEFAULT    1 __warn
    67: 0080013e    79 FUNC    GLOBAL DEFAULT    1 cputs
    68: 008002a6    31 FUNC    GLOBAL DEFAULT    1 exit
    69: 00800212    34 FUNC    GLOBAL DEFAULT    1 sys_wait
    70: 008001e3    27 FUNC    GLOBAL DEFAULT    1 sys_exit
    71: 00200010     0 NOTYPE  GLOBAL DEFAULT    6 __STAB_BEGIN__
    72: 00800ad9    40 FUNC    GLOBAL DEFAULT    1 strlen
    73: 00800292    20 FUNC    GLOBAL DEFAULT    1 sys_pgdir
    74: 00800c49    51 FUNC    GLOBAL DEFAULT    1 strchr
    75: 00800263    20 FUNC    GLOBAL DEFAULT    1 sys_getpid

No version information found in this file.

bigarray被分配到了bss段
zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ readelf -a obj/__user_testbss.out  |grep -w bigarray
    46: 00802020 0x400000 OBJECT  GLOBAL DEFAULT    4 bigarray
zx@zx:~/2019/00_OS/02_ucore/labs/lab5$

















【Q】
  trap 0x0000000e Page Fault
  err  0x00000006





【Q】 bigarray 为何放到bss中





【Q】这样看的话 ROUNDDOWN 也会导致 一些 负的 索引有问题 

【A】负索引测试
#define ARRAYSIZE (1024*1024)
neg


    //neg
    //bigarray[0 - 1] = 0;//can not test the issue of out of memory
    //bigarray[0 - 5] = 0;//can not test the issue of out of memory
    //bigarray[0 - 8] = 0;//can not test the issue of out of memory
-1 ~ -8 都没问题


  
vm_start: 0x802000              vm_end: 0xc03000  
  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8
  [ 4] .bss              NOBITS          00802020 007008 400000 00  WA  0   0 32  

bigarray[0 - 1]         00802020 + 4 * (0 - 1) =  80201C
...
bigarray[0 - 6]         00802020 + 4 * (0 - 6) =  802008
bigarray[0 - 7]         00802020 + 4 * (0 - 7) =  802004
bigarray[0 - 8]         00802020 + 4 * (0 - 8) =  802000

上面都还在这个vma的虚拟地址范围之内，该vma是RW的，暂时没问题
但是看data段，是 00802000~00802008，
bigarray[0 - 8]   bigarray[0 - 7]  bigarray[0 - 6] 这三个其实已经到了data段
那么本意修改bss段的值时，因为所以有问题，就修改了data段的值。


虽然bigarray[0 - 6]    等几个已经从bss段，到了data段
但好歹还是在同一个vma中，所以find_vma不会失败。
检测不到越界
【！！！】
（其实这很危险，因为data段的数据已经被修改了，
也不会立马体现出来问题，比较头疼）

-----------------
但是
bigarray[0 - 9]         00802020 + 4 * (0 - 9) =  801FFC

这个已经不再这个vma中了

vm_start: 0x800000              vm_end: 0x802000  
  [ 1] .text             PROGBITS        00800020 005020 00109e 00  AX  0   0  1
  [ 2] .rodata           PROGBITS        008010c0 0060c0 0003b8 00   A  0   0 32


801FFC目前已经跑到 text rodata中的vma去了

看上面分析的vma的分布

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x001000 0x00200000 0x00200000 0x038b6 0x038b6 RW  0x1000          stab
  LOAD           0x005020 0x00800020 0x00800020 0x01458 0x01458 R E 0x1000          text  rodata
  LOAD           0x007000 0x00802000 0x00802000 0x00008 0x400020 RW  0x1000         data
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10            ustack

text rodata中的vma的flag 是 R E   ，可以读和执行，因为算是代码段的内容
所以是不能写的
因此执行 bigarray[0 - 9] = 0; 有问题的，看下面的测试报错，就是这样的

  

Making sure bss works right...
Yes, good.  Now doing a wild write off the end...
testbss may pass.
bigarray arrd: 0x802020
do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write【！！！】
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x0080146d
  ecx  0xaffffec8
  eax  0x00000018
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000e Page Fault
  err  0x00000007
  eip  0x00801096
  cs   0x----001b
  flag 0x00000282 SF,IF,IOPL=0
  esp  0xafffff80
  ss   0x----0023
killed by kernel.
kernel panic at kern/trap/trap.c:220:
    handle user mode pgfault failed. ret=-3

stack trackback:
ebp:0xc0392f08 eip:0xc0100aeb args:0xc010c564 0xc0392f4c 0x000000dc 0x008000d6
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc0392f38 eip:0xc0100e4b args:0xc010c910 0x000000dc 0xc010c99c 0xfffffffd
    kern/debug/panic.c:28: __panic+105
ebp:0xc0392f78 eip:0xc0102957 args:0xc0392fb4 0x00000000 0x00800020 0x0000001b
    kern/trap/trap.c:220: trap_dispatch+292
ebp:0xc0392fa8 eip:0xc0102b93 args:0xc0392fb4 0x00000000 0x00000000 0xafffffa8
    kern/trap/trap.c:319: trap+74
ebp:0xafffffa8 eip:0xc0102be8 args:0x00000000 0x00000000 0x00000000 0x00000000
    kern/trap/trapentry.S:24: <unknown>+0
ebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000
    user/libs/umain.c:7: umain+10
Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.



写不行，看看读呢？

int a = bigarray[0 - 9]
cprintf("a: %u\n", a);

kernel_execve: pid = 2, name = "testbss".
user_main: name = "testbss", binary = "0xc018540c", size = "30979"
Making sure bss works right...
Yes, good.  Now doing a wild write off the end...
testbss may pass.
bigarray arrd: 0x802020
a: 0
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x00801494
  ecx  0xaffffec8
  eax  0x00000005
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000d General Protection
  err  0x000000a2
  eip  0x008010b3
  cs   0x----001b
  flag 0x00000282 SF,IF,IOPL=0
  esp  0xafffff80
  ss   0x----0023
unhandled trap.
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:472:
    initproc exit.

倒是可以读！

其实上面无论读和写，对bigarray[0 - 9]来说，
都是越界的，到了text rodata中的vma，
但是该vma是 R E 属性的，写自然失败，读可以

但是如果bigarray[0 - 9] 不再任何vma中，那么find_vma会失败

【！！！】
bigarray[0 +/- X]，需要 读/写 某个地址，
那么该地址，（其实是个虚拟地址）
（1）如果在某个vma中，那么看这个vma的属性是什么，能否满足 读/写
不能就会报出相应的错误，在err中会有反应
（1.1）当然，如果跨到别的vma中了，该vma可读，读了不会破坏内存
（1.2）但是如果写了，那么内存就被破坏了，会造成后续运行的诡异，
很难很容易的发现问题所在，效应不是立马显现的。
（就像上面的bigarray[0 - 6]，bigarray[0 - 7]，bigarray[0 - 8]，
已经跑到data段了，那么data段的程序数据就被莫名其妙的修改了，
会造成后续的运行发生想不到的问题，也很难排查
想想当年自己的代码中，数组index就越了俩单位，很难查出来）

（2）如果不在任何一个该进程的vma中，那么直接报错，not valid addr c03020, and  can not find it in vma


【！！！】
如果在自己的vma中越界了，也就是说越界到了通过 ROUNDDOWN 和 ROUNDUP 扩展的区域中，
那么不用担心物理内存映射的问题，因为ROUNDDOWN 和 ROUNDUP 处理之后，

通过pgdir_alloc_page分配内存，都是按照整页对齐，整页分配的。
扩展的区域也在该页中
两头扩展，最多就在 两头的整页中，所以不会映射物理内存失败。


------



bigarray[0 - 15] = 0;


user_main: name = "testbss", binary = "0xc018540c", size = "30979"
Making sure bss works right...
Yes, good.  Now doing a wild write off the end...
testbss may pass.
bigarray arrd: 0x802020
do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x0080146d
  ecx  0xaffffec8
  eax  0x00000018
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000e Page Fault
  err  0x00000007
  eip  0x00801096
  cs   0x----001b
  flag 0x00000282 SF,IF,IOPL=0
  esp  0xafffff80
  ss   0x----0023
killed by kernel.
kernel panic at kern/trap/trap.c:220:
    handle user mode pgfault failed. ret=-3

stack trackback:
ebp:0xc0392f08 eip:0xc0100aeb args:0xc010c564 0xc0392f4c 0x000000dc 0x008000d6
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc0392f38 eip:0xc0100e4b args:0xc010c910 0x000000dc 0xc010c99c 0xfffffffd
    kern/debug/panic.c:28: __panic+105
ebp:0xc0392f78 eip:0xc0102957 args:0xc0392fb4 0x00000000 0x00800020 0x0000001b
    kern/trap/trap.c:220: trap_dispatch+292
ebp:0xc0392fa8 eip:0xc0102b93 args:0xc0392fb4 0x00000000 0x00000000 0xafffffa8
    kern/trap/trap.c:319: trap+74
ebp:0xafffffa8 eip:0xc0102be8 args:0x00000000 0x00000000 0x00000000 0x00000000
    kern/trap/trapentry.S:24: <unknown>+0
ebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000
    user/libs/umain.c:7: umain+10
Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.
K>


---------------------



【Q】正好凑够 整页，测试情况
【A】正好凑够 整页，测试一越界就能检测到

#define ARRAYSIZE (1024*1024 - 8)


此时
zx@zx:~/2019/00_OS/02_ucore/labs/lab5$ readelf -a obj/__user_testbss.out

  [ 4] .bss              NOBITS          00802020 007008 3fffe0 00  WA  0   0 32

  
  00802020 + 3fffe0 = C02000
  
  正好是以整页结尾的，不包含C02000这个地址
  所以访问
bigarray[ARRAYSIZE]             00802020 + 4 * (1024 * 1024)     =  C02020

就会越界，马上检测到，find_vma立马失效了



------------

bigarray[ARRAYSIZE - 1] = 0;
正常

check_swap() succeeded!
++ setup timer interrupts
kernel_execve: pid = 2, name = "testbss".
user_main: name = "testbss", binary = "0xc018540c", size = "30979"
Making sure bss works right...
Yes, good.  Now doing a wild write off the end...
testbss may pass.
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x0080145a
  ecx  0xaffffec8
  eax  0x00000012
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000d General Protection
  err  0x000000a2
  eip  0x0080108c
  cs   0x----001b
  flag 0x00000282 SF,IF,IOPL=0
  esp  0xafffff80
  ss   0x----0023
unhandled trap.
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:472:
    initproc exit.

stack trackback:
ebp:0xc038bf88 eip:0xc0100aeb args:0xc010c564 0xc038bfcc 0x000001d8 0xc038bfb8
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc038bfb8 eip:0xc0100e4b args:0xc010e32d 0x000001d8 0xc010e37f 0x00000000
    kern/debug/panic.c:28: __panic+105
ebp:0xc038bfe8 eip:0xc010a352 args:0x00000000 0x00000000 0x00000000 0x00000010
    kern/process/proc.c:472: do_exit+91
Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.
K> qemu: terminating on signal 2



------
------

bigarray[ARRAYSIZE] = 0;

立马检测到越界了

kernel_execve: pid = 2, name = "testbss".
user_main: name = "testbss", binary = "0xc018540c", size = "30979"
Making sure bss works right...
Yes, good.  Now doing a wild write off the end...
testbss may pass.
not valid addr c02000, and  can not find it in vma
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x0080145a
  ecx  0xaffffec8
  eax  0x00000012
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000e Page Fault
  err  0x00000006
  eip  0x00801082
  cs   0x----001b
  flag 0x00000282 SF,IF,IOPL=0
  esp  0xafffff80
  ss   0x----0023
killed by kernel.
kernel panic at kern/trap/trap.c:220:
    handle user mode pgfault failed. ret=-3

stack trackback:
ebp:0xc0392f08 eip:0xc0100aeb args:0xc010c564 0xc0392f4c 0x000000dc 0x008000d6
    kern/debug/kdebug.c:350: print_stackframe+21
ebp:0xc0392f38 eip:0xc0100e4b args:0xc010c910 0x000000dc 0xc010c99c 0xfffffffd
    kern/debug/panic.c:28: __panic+105
ebp:0xc0392f78 eip:0xc0102957 args:0xc0392fb4 0x00000000 0x00800020 0x0000001b
    kern/trap/trap.c:220: trap_dispatch+292
ebp:0xc0392fa8 eip:0xc0102b93 args:0xc0392fb4 0x00000000 0x00000000 0xafffffa8
    kern/trap/trap.c:319: trap+74
ebp:0xafffffa8 eip:0xc0102be8 args:0x00000000 0x00000000 0x00000000 0x00000000
    kern/trap/trapentry.S:24: <unknown>+0
ebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000
    user/libs/umain.c:7: umain+10
Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.
K> qemu: terminating on signal 2

zx@zx:~/2019/00_OS/02_ucore/labs/lab5$
zx@zx:~/2019/00_OS/02_ucore/labs/lab5$




【Q】分析上面该测试用例中所有的trap 和 err








【Q】几段数据结合着看
【A】
（1）
vm_start: 0x200000              vm_end: 0x204000  
  [ 5] .stab_info        PROGBITS        00200000 001000 000010 00  WA  0   0  1
  [ 6] .stab             PROGBITS        00200010 001010 002b45 0c   A  7   0  4
  [ 7] .stabstr          STRTAB          00202b55 003b55 000d61 00   A  0   0  1

（2）  
vm_start: 0x800000              vm_end: 0x802000  
  [ 1] .text             PROGBITS        00800020 005020 00109e 00  AX  0   0  1
  [ 2] .rodata           PROGBITS        008010c0 0060c0 0003b8 00   A  0   0 32

（3）
vm_start: 0x802000              vm_end: 0xc03000  
  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8
  [ 4] .bss              NOBITS          00802020 007008 400000 00  WA  0   0 32

（4）
vm_start: 0xaff00000            vm_end: 0xb0000000
  看来只有 0xaff00000-0xb0000000 是可用的


  
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00800020 005020 00109e 00  AX  0   0  1
  [ 2] .rodata           PROGBITS        008010c0 0060c0 0003b8 00   A  0   0 32
  [ 3] .data             PROGBITS        00802000 007000 000008 00  WA  0   0  8
  [ 4] .bss              NOBITS          00802020 007008 400000 00  WA  0   0 32
  [ 5] .stab_info        PROGBITS        00200000 001000 000010 00  WA  0   0  1
  [ 6] .stab             PROGBITS        00200010 001010 002b45 0c   A  7   0  4
  [ 7] .stabstr          STRTAB          00202b55 003b55 000d61 00   A  0   0  1
  [ 8] .shstrtab         STRTAB          00000000 007008 00004e 00      0   0  1
  [ 9] .symtab           SYMTAB          00000000 007210 0004c0 10     10  27  4
  [10] .strtab           STRTAB          00000000 0076d0 000233 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x001000 0x00200000 0x00200000 0x038b6 0x038b6 RW  0x1000      stab
  LOAD           0x005020 0x00800020 0x00800020 0x01458 0x01458 R E 0x1000      text  rodata
  LOAD           0x007000 0x00802000 0x00802000 0x00008 0x400020 RW  0x1000     data
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10        ustack
  
（1）
0x00200000 + 0x038b6 = 2038B6， UP之后  204000
（2）
0x00800020 + 0x01458 = 801478， UP之后  802000
（3）
0x00802000 + 0x400020 = C02020，UP之后  C03000
data段是从 00802000开始，大小8，所以00802008结束
bss段是从  00802020开始，中间的不知道怎么处理的，elf估计采用了某种对齐机制吧
（4）
用户栈，elf没办法设置位置，是运行时的空间，
可以在user.ld中设置，由该脚本规定，比较灵活





【Q】误修改data段数据
【A】
添加一个全局变量  int aaa = 3;
aaa肯定在data段，查看其地址

  [ 3] .data             PROGBITS        00802000 007000 00000c 00  WA  0   0  8
  [ 4] .bss              NOBITS          00802020 00700c 400000 00  WA  0   0 32 

    44: 00802008     4 OBJECT  GLOBAL DEFAULT    3 aaa  
aaa位于 00802008地址处

可读可写的
  LOAD           0x007000 0x00802000 0x00802000 0x00008 0x400020 RW  0x1000         data

    47: 00802020 0x400000 OBJECT  GLOBAL DEFAULT    4 bigarray  
bigarray[0 - 6]         00802020 + 4 * (0 - 6) =  802008 

所以 bigarray[0 - 6] 是可以访问到aaa变量的

    
int aaa = 3;

main(void) {
    //mod aaa in data segment by mistaken
    cprintf("aaa before mod: %d\n", aaa);
    bigarray[0 - 6] = 7;
    cprintf("aaa after  mod: %d\n", aaa);   
}
    
aaa before mod: 3
aaa after  mod: 7

可以看到已经误修改了aaa的值，而且没有报出任何错误




【Q】
【A】
俩big数组
第一个越界，越到第二个的位置
看反应   读写 测试


uint32_t bigarray[ARRAYSIZE];
uint32_t bigarray222[ARRAYSIZE];

    46: 00802020 0x400000 OBJECT  GLOBAL DEFAULT    4 bigarray
    76: 00c02020 0x400000 OBJECT  GLOBAL DEFAULT    4 bigarray222
    
（1）
    bigarray222[ARRAYSIZE + 1024 - 9] = 0xffffffff;
    bigarray222[ARRAYSIZE + 1024 - 8] = 0xffffffff;
    bigarray222[ARRAYSIZE + 1024] = 0xffffffff;
        
    
kernel_execve: pid = 2, name = "testbss".
user_main: name = "testbss", binary = "0xc018540c", size = "31007"
Making sure bss works right...
Yes, good.  Now doing a wild write off the end...
testbss may pass.
bigarray222[ARRAYSIZE + 1024 - 9]: 0xffffffff
not valid addr 1003000, and  can not find it in vma
trapframe at 0xc0392fb4
  edi  0x00000000
  esi  0x00000000
  ebp  0xafffffa8
  oesp 0xc0392fd4
  ebx  0x00000000
  edx  0x0080158b
  ecx  0xaffffec8
  eax  0x0000002e
  ds   0x----0023
  es   0x----0023
  fs   0x----0000
  gs   0x----0000
  trap 0x0000000e Page Fault
  err  0x00000006
  eip  0x0080111a
  cs   0x----001b
  flag 0x00000282 SF,IF,IOPL=0
  esp  0xafffff80
  ss   0x----0023
killed by kernel.
kernel panic at kern/trap/trap.c:220:
    handle user mode pgfault failed. ret=-3
    
bigarray222     00c02020 ~ 1002020
1002020     up   1003000
所以
bigarray222[ARRAYSIZE + 1024 - 9]       1002FFC     不报错
bigarray222[ARRAYSIZE + 1024 - 8]       1003000     find_vma失败


（2）
    bigarray[ARRAYSIZE + 1024 - 9] = 0xffffffff;
    cprintf("bigarray222[1024 - 9]: %p\n", bigarray222[1024 - 9]);
    bigarray[ARRAYSIZE + 1024 - 8] = 0xfffffffe;
    cprintf("bigarray222[1024 - 8]: %p\n", bigarray222[1024 - 8]);
    bigarray[ARRAYSIZE + 1024] = 0xfffffffd;
    cprintf("bigarray222[1024]: %p\n", bigarray222[1024]);

kernel_execve: pid = 2, name = "testbss".
user_main: name = "testbss", binary = "0xc018540c", size = "31007"
Making sure bss works right...
100 ticks
End of Test.
Yes, good.  Now doing a wild write off the end...
testbss may pass.
bigarray222[1024 - 9]: 0xffffffff
bigarray222[1024 - 8]: 0xfffffffe
bigarray222[1024]: 0xfffffffd

    
    bigarray的赋值，错误的修改到了bigarray222
    
    
【Q】过完年回来后，gdbinit脚本中定义打proc的函数
还有sm_priv






--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
pgdir


kernel_execve: pid = 2, name = "pgdir".
user_main: name = "pgdir", binary = "0xc016ea07", size = "30892"
I am 2, print pgdir.
-------------------- BEGIN --------------------
PDE(001) 00000000-00400000 00400000 urw
  |-- PTE(00004) 00200000-00204000 00004000 urw
PDE(001) 00800000-00c00000 00400000 urw
  |-- PTE(00002) 00800000-00802000 00002000 ur-
  |-- PTE(00001) 00802000-00803000 00001000 urw
PDE(001) afc00000-b0000000 00400000 urw
  |-- PTE(00004) afffc000-b0000000 00004000 urw
PDE(0e0) c0000000-f8000000 38000000 urw
  |-- PTE(38000) c0000000-f8000000 38000000 -rw
PDE(001) fac00000-fb000000 00400000 -rw
  |-- PTE(00001) fac00000-fac01000 00001000 urw
  |-- PTE(00001) fac02000-fac03000 00001000 urw
  |-- PTE(00001) faebf000-faec0000 00001000 urw
  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
--------------------- END ---------------------
pgdir pass.


--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------













                                                        
